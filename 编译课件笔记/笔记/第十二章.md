# 语法分析程序的自动生成技术

## 1、LL分析法

自左向右扫描，自左向右分析和匹配输入串。分析过程表现为最左推导的性质

是**自顶向下方法**，需要消除左递归

![image-20241120095743483](D:\ziliao\编译原理\笔记\12\1.png)

![image-20241120095834710](D:\ziliao\编译原理\笔记\12\2.png)

**行是所有的Vn，列是所有的Vt，加上‘#’**

![image-20241120100702200](D:\ziliao\编译原理\笔记\12\3.png)

![image-20241120100747678](D:\ziliao\编译原理\笔记\12\4.png)

具体看课件的示例进行理解

**已识别出来的终结符号和符号栈内的现有符号排列（从栈顶到栈底），正好构成该最左推导过程！**

（正好是栈的顺序）

#### 2、分析表的构造

![image-20241120103230760](D:\ziliao\编译原理\笔记\12\5.png)

**如何求FIRST集**：

![image-20241120103747710](D:\ziliao\编译原理\笔记\12\6.png)

![image-20241120103803951](D:\ziliao\编译原理\笔记\12\7.png)

![image-20241120104354252](D:\ziliao\编译原理\笔记\12\8.png)

FOLLOW(B)范围比FOLLOW(A)大

![image-20241120105153443](D:\ziliao\编译原理\笔记\12\9.png)

![image-20241120105209276](D:\ziliao\编译原理\笔记\12\10.png)

**构造分析表**

算法：

设A∷=αi为文法中的任意一条规则，a为任一终结符或#。

1、若a∈FIRST(αi )，则将A ::=αi放入M [ A , a ]。 

​	表示：A在栈顶，输入符号是a，应选择αi去匹配。

2、若αi=ε或αi =+=>ε，而且a∈FOLLOW (A)， 则A ::= ε 放入M [ A , a ]，表示A 已匹配输入串成功， 其后继符号终结符a 由A 后面的语法成分去匹配。

3、把所有无定义的M [ A , a ]都标上error。

![image-20241120105855890](D:\ziliao\编译原理\笔记\12\11.png)

#### 3、LL(1)文法

定义：一个文法G，其分析表M不含多重定义入口（即分 析表中无两条以上规则），则称它是一个LL(1)文法。

定理：文法G是LL(1)文法的充分必要条件是：对于G的 每个非终结符A的任意两条规则A::=α|β,下列条件成立：

1、FIRST(α) ∩ FIRST(β) = Ф  

2、若β=*=> ε,  则FIRST(α) ∩ FOLLOW(A) = Ф

有些M[A, a]中可能有若干条规则，这称为 分析表的多重定义或者多重入口。

可以证明：如果G是左递归或二义的，那么M至少含有 一个多重定义入口。

**反之，一个文法G的预测分析表M不含多重定义入口， 当且仅当该文法为LL(1)的。**

#### 4、LL分析的错误恢复----补充

错误恢复的基本思想是：跳过一些输入符号，直到期望的同步符号之一出现为止。

同步符号（可重新开始继续分析的输入符号）集合通常可按以下方法确定：

1) 把FOLLOW(A)的所有符号加入A的同步符号集。如果我 们跳读一些输入符号直到出现FOLLOW(A)的符号，之 后把A 从栈中弹出，继续往下分析即可。
2) 只用FOLLOW(A)作为非终结符A的同步符号集是不够的 (容易造成跳读过多，如输入串中缺少语句结束符分号 时)。此时可将作为语句开头的关键字加入它的同步符号 集，从而避免这种情况的发生。
3) 把FIRST(A)的符号加入非终结符A的同步符号集中。
4) 如果非终结符A可以产生空串，那么推导ε的产生式可以作为缺省的情况。这样做可以推迟某些错误检查，但不会漏过错误。
5) 如果终结符在栈顶而不能匹配，则可弹出该终结符并发出一条信息后继续分析。这好比把所有其他符号均作为该符号的同步集合元素。

## 2、自底向上分析

移进—规约分析

要点：设置符号栈，用来纪录分析的历史和现状， 并根据所面临的状态，确定下一步动作是移 进还是规约。

栈里存放的是识别出的句型的某一部分

分析过程： 

1. 把输入符号串按顺序一个一个地移进符号栈（一次移一个）；
2. 检查栈中符号，当在栈顶的若干符号形成当前句型的句柄时，就根据规则进行规约——将句柄从符号栈中弹出，并将相应的非终结符号压入栈内（即规则的左部符号），然后再检查栈内符号串是否形成新的句柄，若有就再进行规约，否则移进符号；
3. 分析一直进行到读到输入串的右界符为止。最后，若栈中仅含有**左界符号和识别符号**，则表示分析成功，否则失败。

![image-20241127100222882](D:\ziliao\编译原理\笔记\12\12.png)

![image-20241127100611041](D:\ziliao\编译原理\笔记\12\13.png)

句柄是最左简单短语，当前树下句柄是b

栈内符号串+ 未处理输入符号串=当前句型； 句柄都在栈顶

**未真正解决句柄的识别问题**

不能认为：对句型xuy 而言，若有U∷= u，即 U =>u 就断定u是简单短语，u 就是句柄，而是要同时满足 Z =*=>xUy。

## 3、算符优先分析

仿效算术式的四则运算。

预先**规定相邻终结符**之间的优先关系，然后利用这种优先关系来确定句型的“句柄”， 并进行规约

使用优先关系矩阵

（2型文法证明：任意句型都只有一个句柄；唯一的语法树，唯一的推导过程）

![image-20241127102158956](D:\ziliao\编译原理\笔记\12\14.png)

矩阵元素空白处表示这两个终结符不能相邻，故没有优先关系。

一般而言，a代表左侧，b代表右侧

**算法**：当栈顶项（或次栈顶项）终结符的优先级大于栈外的终结符的优先级则进行规约，否则移进。

![image-20241127102342342](D:\ziliao\编译原理\笔记\12\15.png)

**注意：只看相邻终结符的关系**

**重要说明**：

(1)上述分析过程不一定是严格的最左规约（即不一定是规范规约）。也就是每次规约不一定是规约当前句型的句柄，而是句柄的变形，但也是短语。

(2) 实际应用中，文法终结符间优先关系一般不用矩阵表示，而是采用两个**优先函数**来表示：

f —栈内优先函数 g —栈外优先函数

若a < b       则令f ( a ) < g ( b )；a = b   f ( a ) = g ( b ); a > b   f ( a ) > g ( b )

由于终结符多的时候矩阵太大。

![image-20241127102948028](D:\ziliao\编译原理\笔记\12\16.png)

缺点：可能掩盖错误。例如对 i i + i *+i ( )，使用优先函数就会将其误认为是合法的句子。

![image-20241127103404998](D:\ziliao\编译原理\笔记\12\17.png)

句柄只看同一层节点

### 3.1、算符优先文法（OPG）

算符文法（OG）的定义：若文法中无形如U∷= …VW…的规则，这里V,  W∈Vn 则称G为OG文法，也就是算符文法。

**算符文法不允许两个非终结符相邻！**

![image-20241127104355918](D:\ziliao\编译原理\笔记\12\18.png)

**对比前面规约的过程，若W=>b，则规约过程先规约到W，再规约到U，所以优先关系a<b;**

**若W=>...a，则对于句子先从a规约到W，再和b规约到U**

**a>b 不一定有b<a**，因为b<a意味着存在W，b在a左侧，W推得a；而这种情况与a>b无关

![image-20241127105259716](D:\ziliao\编译原理\笔记\12\19.png)

**结合规约和语法树理解优先关系**

![image-20241127105825567](D:\ziliao\编译原理\笔记\12\20.png)

FIRSTVT是终结符集合，不是FIRST集；包括的是最左侧的符号

LASTVT是最右侧终结符集合

![image-20241127105943181](D:\ziliao\编译原理\笔记\12\21.png)

**构造FIRSTVT(U)的算法**

1) 若有规则U∷= b…或U∷= V b…    则b∈FIRSTVT(U)（FIRSTVT的定义中一步推导）
2) 若有规则U∷= V…且b∈FIRSTVT(V), 则b∈FIRSTVT(U) （FIRSTVT的定义中多步推导）

![image-20241127110302447](D:\ziliao\编译原理\笔记\12\22.png)

![image-20241127110623085](D:\ziliao\编译原理\笔记\12\23.png)

LASTVT构造同理

![image-20241127112238016](D:\ziliao\编译原理\笔记\12\24.png)

**出现冲突，说明不是OG文法**

这里的“句柄”是**最左素短语**，素短语必须包含一个Vt，这种算法先规约最左素短语，而不是句柄。

![image-20241127112458610](D:\ziliao\编译原理\笔记\12\25.png)

![image-20241127112529958](D:\ziliao\编译原理\笔记\12\26.png)

注意：出现在aj 左端和ai 右端的非终结符号一定属于这个素短语，因为我们的运算是中缀形式 给出的（OPG文法的特点）

Na **NaN** aN => Na**W**aN

![image-20241201095614217](D:\ziliao\编译原理\笔记\12\27.png)

规约找**左尖括弧和右尖括弧之间**，即素短语

1. 每次规约的最左子串，确实是当前句型的最左素短语(从语法树可以看出来)

2. 规约的不都是真正的句柄

3. 没有完全按规则进行规约，因为素短语不一定是简单短语
4. 中间规约的过程可能包含多步规约

![image-20241201095844281](D:\ziliao\编译原理\笔记\12\28.png)

**问题**：当只有一个Vt时，可以直接推出上一步的Vn，但是这不一定符合句子

![image-20241201100153800](D:\ziliao\编译原理\笔记\12\29.png)

## 4、LR分析法

从左到右扫描(L)自底向上进行规约(R)

是规范规约，也即最右推导。属于下推自动机（包括栈；有穷自动机没有栈）

LR分析器有三部分:  状态栈、分析表、控制程序

状态栈：放置分析器状态和文法符号。（之前的栈只放符号）

分析表：由两个矩阵组成，其功能是指示分析器的动作，是移进还是规约，根据不同的文法类要采用不同的构造方法。

#### 分析表的种类

LR0（向前看0步）, SLR（向前看1步）, LR1（向前看1步），LALR

**只考SLR**，但是LALR有用

![image-20241201101157002](D:\ziliao\编译原理\笔记\12\30.png)

一般把状态栈分成两部分

![image-20241201101251473](D:\ziliao\编译原理\笔记\12\31.png)

规范句型：通过规范规约得到的句型。

规范句型前缀：将输入串的剩余部分与其连结起来就构成了规范句型。如：x1 x2 ..... xm ai...an为规范句型。(x1到xm是栈里已经规约的，是“前缀”，后面ai到an还没有规约)

活前缀：若分析过程能够保证栈中符号均是规范句 的前缀，则表示输入串已分析过的部分没有语法错误，所以称为规范句型的活前缀。

**规范句型的活前缀：**

对于句型αβt，β表示句柄，如果αβ= u1u2…ur， 那么符号串u1 u2 …ui **(1≤i≤r)** 即是句型αβt的活前缀。

![image-20241201102243070](D:\ziliao\编译原理\笔记\12\32.png)

i是句柄，也就是$\beta$。所以前面的都是$\alpha$。活前缀只考虑$\alpha\beta$。不再考虑后面的内容，+无法进栈

![image-20241201102638331](D:\ziliao\编译原理\笔记\12\33.png)

M = ( S, V, GOTO, S0, Z )

状态转移函数GOTO是定义了一个以文法符号集为字母表的有穷自动机，该自动机识别文法所有规范句型的活前缀。

![image-20241201103046525](D:\ziliao\编译原理\笔记\12\34.png)

**分析动作：**

①移进(shift) ACTION[ Si , a ] = s

动作：将a 推进栈，并设置新的栈顶状态为Sj。 Sj = GOTO[ Si, a ]，并将指针指向下一个输入符号

②规约(reduce) ACTION[ Si, a ] = rd

d：文法规则编号 (d)  A→β

动作：将符号串β(假定长度为n ) 连同状态从栈内弹出，再把A推进栈，并设置新的栈顶状态为Sj。 Sj = GOTO[ Si-n , A ]

③接受(accept) ACTION[ Si , # ] = accept

④出错(error)  ACTION[ Si , a ] = error  a∈Vt

![image-20241201103451313](D:\ziliao\编译原理\笔记\12\35.png)

![image-20241201103506534](D:\ziliao\编译原理\笔记\12\36.png)

![image-20241201103522963](D:\ziliao\编译原理\笔记\12\37.png)

S的下标代表下一个状态，r的下标代表使用哪个产生式。

![image-20241201104407316](D:\ziliao\编译原理\笔记\12\38.png)

符号就是规范句型的活前缀

将上述过程每一步的活前缀与剩余 输入串连接起来——每一步的句型

最左规约（规范规约），最右推导（规范推导）

LR分析法就是最左规约的过程。

**注意**：在表中进行规约后，要将整个规约式和中间的状态都拿走，规约得到的新的式子的状态看前面的状态数字，查goto表 （Sj = GOTO[ Si-n , A ]）

### 构造LR分析表

#### 1、构造DFA

DFA 是一个五元式

M = ( S,   V,    GOTO,    S0,    Z )

S：有穷状态集

在此具体情况下，**S = LR(0)项目集规范族**。

**项目集规范族**：其元素是由**项目**所构成的集合。

V：文法字汇表； S0：初始状态； Z：终态集合 Z = S -{ S0 }   **除S0 以外，其余全部是终态**。

（由于要识别出活前缀，而活前缀的前缀也是活前缀，所以应当都能识别出来，所以除S0以外全是终态）

#### 2、构造LR(0)

LR(0)是DFA的状态集，其中每个状态又都是项目的集合。

项目：文法G 的每个产生式（规则）的右部**添加一个圆点**就构成一个项目。

注意：只能放一次点

例：产生式：A→ X Y Z 项 目：A→ . X Y Z;  A→ X .Y Z;  A→ X Y. Z;   A→ X Y Z . 

产生式：A→ε 项 目：A→.

项目的直观意义：指明在分析过程中的某一时刻的已经规约部分和等待规约部分。

#### 构造LR(0)文法的方法(三步)

1. 将文法扩充

   目的：使构造出来的分析表只有一个接受状态，这是为了实现上的方便。（开始符号如果有两个及以上候选式，必须扩充）

   方法：修改文法，使识别符号（开始符号）的规则只有一条。

2. 根据文法列出所有的项目（穷举）
3. 将有关项目组合成集合，即DFA中的状态；所有状态构成了LR(0) 项目集规范族。

![image-20241201110342434](D:\ziliao\编译原理\笔记\12\39.png)

![image-20241201110520472](D:\ziliao\编译原理\笔记\12\40.png)

使用上一章的NFA确定化和DFA最小化，有

![image-20241201111143965](D:\ziliao\编译原理\笔记\12\41.png)

实际上使用下面的方法

③将有关项目组成项目集，所有项目集构成的集合即为 LR(0)。

**项目集闭包closure**

令I是文法G'的任一项目集合，

```
Procedure  closure(I);
	begin
		将属于I 的项目加入closure(I);
 		repeat
 			for  closure(I)中的每个项目A→α.Bβ(B∈Vn)   do
				将B→. r ( r∈V* )加入closure(I)
 		until   closure(I)不再增大
	end
```

![image-20241201111653150](D:\ziliao\编译原理\笔记\12\42.png)

**状态转移函数GOTO的定义:**

 GOTO ( I, X ) = closure (J)

 I：项目集合  X：文法符号，X∈V  J：项目集合

J = { 任何形如A→αX.β的项目 | A→α.Xβ∈I }

closure (J)：项目集 J 的闭包仍是项目集合。

LR (0) 项目集规范族的构造算法:

```
G'→LR (0)
procedure   ITEMSETS (G');
 	begin
 		LR(0):={closure({E'→.E})};
 		repeat
 			for  LR (0)中的每个项目集I 和G' 的每个符号X  do
 				if  GOTO (I , X) 非空且不属于LR(0)
 					then   把GOTO (I , X) 放入LR(0)中
			until   LR(0)不再增大
end
```

#### 有效项目定义

若项目A→α.β，对活前缀φα有效， 则其条件是存在规范推导 E’ =>φA w =>φα βw。

有效项目能预测分析的下一步动作:

E→ E + T .   表示已将输入串规约为E + T，下一步 应该将E + T 规约为E

T→T. * F     表示已将输入串规约为T，下一步动作是移进输入符号*

![image-20241204160236696](D:\ziliao\编译原理\笔记\12\43.png)

**GOTO表可由DFA直接求出**

假若一个文法G的拓广文法G'的活前缀识别自 动机中的每个状态(项目集)不存在下述情况：

1) 既含移进项目又含归约项目
2) 含有多个归约项目

![image-20241204161230146](D:\ziliao\编译原理\笔记\12\44.png)

对于I9状态第一个式子，由于E->E+T.，所以遇见E的**Follow集**时，将E+T.规约为E

####   求SLR文法ACTION表的一般方法

![image-20241204161742136](D:\ziliao\编译原理\笔记\12\45.png)

![image-20241204162201562](D:\ziliao\编译原理\笔记\12\46.png)

每个SLR(1)文法都是无二义的。但也存在许多无二义文 法不是SLR(1)的。

![image-20241204163106957](D:\ziliao\编译原理\笔记\12\47.png)

判断SLR1：如果没有冲突，或者有冲突但可以用Follow集解决。

否则不是SLR1（FOLLOW集合提供的信息太泛）

## LR1分析法

![image-20241204163533246](D:\ziliao\编译原理\笔记\12\48.png)

![image-20241204164629373](D:\ziliao\编译原理\笔记\12\49.png)

右侧是搜索符号集合（β的FIRST集）

