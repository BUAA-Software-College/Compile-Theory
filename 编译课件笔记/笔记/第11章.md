# 词法分析程序的自动生成技术

## 1、正则表达式与有穷自动机

正则表达式和正则集合的递归定义：

有字母表$\Sigma$，定义在$\Sigma$上的正则表达式和正则集合递归定义如下:

1. $\varepsilon$ 和$\phi$都是$\Sigma$上的正则表达式，它们所表示的正则集合分别为: { $\varepsilon$ } 和$\phi$;
2. 任何$a\in \Sigma$ ，a是正则表达式，它所表示的正则集合为{a}
3. 假定U,V都是$\Sigma$上的正则表达式，它们所表示的正则集合分别记为L(U)和L(V)（L表示Language），那么U | V，U • V和 U* （闭包）也都是$\Sigma$上的正则表达式，它们 所表示的正则集合分别为L( U )∪L( V )、L( U ) • L( V )和L( U*); 
4.  任何$\Sigma$上的正则表达式和正则集合均由1、2和3产生。

![image-20241113100810591](D:\ziliao\编译原理\笔记\11\1.png)

证明正则表达式相等，根据归纳法，证明生成的句子集合相等。

**注意：*是重复，可以是$\varepsilon$，也就是说可以为空**

**性质**：

单位正则表达式$\varepsilon$ ；

满足交换律，结合律，分配律

![image-20241113101418969](D:\ziliao\编译原理\笔记\11\2.png)

## 2、有穷自动机

### 2.1、确定有穷自动机（DFA）

一个确定的有穷自动机（DFA）M是一个五元式: M=（S,$\Sigma$,$\delta$,s0,Z）(文法是四元式）

![image-20241113102152826](D:\ziliao\编译原理\笔记\11\3.png)

![image-20241113102626511](D:\ziliao\编译原理\笔记\11\4.png)

![image-20241113102640651](D:\ziliao\编译原理\笔记\11\5.png)

![image-20241113102720345](D:\ziliao\编译原理\笔记\11\6.png)

### 2.2、非确定的有穷自动机(NFA)

若δ是一个多值函数，且输入可允许为ε，则有穷自动机是 不确定的。即在某个状态下，对于某个输入字符存在多个后继状态。

![image-20241113102807718](D:\ziliao\编译原理\笔记\11\7.png)

初始状态可以是集合，不止一种；

![image-20241113103303825](D:\ziliao\编译原理\笔记\11\8.png)

判断是DFA还是NFA：DFA没有ε，所以如果状态转移函数有ε，那么就是NFA

![image-20241113104238995](D:\ziliao\编译原理\笔记\11\9.png)

### 2.3、NFA确定化

已证明：非确定的有穷自动机与确定的有穷自动机从功能上来说是等价的。

定义1、集合I 的ε-闭包：

令I 是一个状态集的子集，定义ε-closure(I)为： 

1）若s∈I，则s∈ε-closure(I)； 

2）若s∈I，则从s 出发经过任意条ε 弧能够到达的任何 状态都属于ε-closure(I)。 状态集ε-closure(I)称为 I 的ε-闭包。

![image-20241113104850751](D:\ziliao\编译原理\笔记\11\10.png)

![image-20241113104910559](D:\ziliao\编译原理\笔记\11\11.png)

![image-20241113105408634](D:\ziliao\编译原理\笔记\11\12.png)

当不再出现新的状态子集，则算法结束，NFA对应的状态子集就是I这一列

![image-20241113105536304](D:\ziliao\编译原理\笔记\11\13.png)

![image-20241113105553780](D:\ziliao\编译原理\笔记\11\14.png)

### 2.4、正则表达式和DFA等价性

定理：在Σ上的一个字集V（V是Σ*子集）是正则集合，当且仅当 存在一个DFA  M，使得V = L( M )。

## 3、词法分析程序的自动生成器—LEX（LEXICAL）

### 3.1、 LEX源程序

一个LEX源程序主要由三个部分组成： 

1. 规则定义段 2. 识别规则段 3. 用户代码段 

各部分之间用%%隔开。

下推自动机多了一个栈，使自动机可以进入中间状态。

**LEX二义性问题的两条原则**：

1. 最长匹配原则：
2. 最优匹配原则

![image-20241113111828799](D:\ziliao\编译原理\笔记\11\15.png)

## 4、正则文法，正则表达式，NFA相互转化

### 1、有穷自动机->正则文法

算法:

1. 对转换函数f (A, t) = B，可写成一个产生式:A→tB
2. 对可接受状态Z（双圈表示，是终止状态），增加一个产生式：Z→ε
3. 有穷自动机的初态对应于文法的开始符号，有穷自动机的字母表为文法的终结符号集。

![image-20241118155857722](D:\ziliao\编译原理\笔记\11\16.png)

![image-20241118160005312](D:\ziliao\编译原理\笔记\11\17.png)

### 2、正则文法->有穷自动机M

**注意，这是右线性文法的状态图，要和第三章左线性文法的状态图区分**

算法：

1. 字母表与G的终结符号相同。
2. 为G中的每个非终结符生成M的一个状态，G的开始符号S是开始状态S。
3. 增加一个新状态Z，作为NFA的终态。
4. 对G中的形如A→tB，其中t为终结符或ε, A和B为非终 结符的产生式，构造M的一个转换函数f (A, t) = B。
5. 对G中的形如A→t的产生式，构造M的一个转换函数 f (A, t) = Z。

### 3、正则表达式->有穷自动机

![image-20241118161430915](D:\ziliao\编译原理\笔记\11\18.png)

![image-20241118161452577](D:\ziliao\编译原理\笔记\11\19.png)

**类比电路记忆，“与”是“串联”，“或|”是“并联”**

![image-20241118161610740](D:\ziliao\编译原理\笔记\11\20.png)

### 4、有穷自动机->正则式R

算法: 

1) 在M上加两个结点x, y。从x用ε弧连接到M的所有初态 结点，从M的所有终态结点用ε弧连接到y，形成与M 等价的M’。M’只有一个初态x和一个终态y。 
2) 逐步消去M’中的所有结点，直至剩下x和y为止。在消 除结点的过程中，逐步用正则式来标记箭弧。其消结 规则如下：

![image-20241118163519687](D:\ziliao\编译原理\笔记\11\21.png)

### 5、正则文法->正则式

利用以下转换规则，直至只剩下一个开始符号定义 的产生式，并且产生式的右部不含非终结符。

![image-20241118164432369](D:\ziliao\编译原理\笔记\11\22.png)

![image-20241118164512173](D:\ziliao\编译原理\笔记\11\23.png)

### 6、正则式->正则文法

算法： 

1) 对任何正则式r，选择一个非终结符S作为识别符 号，并产生产生式 S→r 

2) 若x, y是正则式，对形为A→xy的产生式，重写为 A→xB和B→y，其中B为新的非终结符，B∈Vn 

   同样，对于 A→x* y   有 A→xA，A→y；A→x| y   有  A→x，A→y

**这种拆法是右线性文法**

一般都不转化为左线性文法，而是转化为右线性的！**原因是左线性文法将递归死循环。**

**正则文法必须全是左线性或者右线性。如果两个混合，则只能是二型文法，上下文无关文法**

### 11.2.4、DFA的简化（最小化）

**对于任一个DFA，存在一个唯一的状态最少的等价的DFA**

一个有穷自动机是化简的 等价于 它没有多余状态并且它的状态 中没有两个是互相等价的。

一个有穷自动机可以通过消除多余状态和合并等价状态而转 换成一个最小的与之等价的有穷自动机。

(1) **有穷自动机的多余状态**：从该自动机的开始状态出发, 任何输入串也不能到达那个状态。

(2) **等价状态**：

1. 一致性条件：状态s 和t 必须同时为可接受状态或不接受状态。 
2. 蔓延性条件：对于所有输入符号，状态s 和t 必须转换到等价的状态里。

对于所有输入符号c，Ic(s) = Ic(t)，即状态s、t 对于c 具有相同的后继，则称s，t 是等价的。

若有穷自动机的状态s 和t 不等价，则称这两个状态是可区别的。

“**分割法**”：把一个DFA（不含多余状态）的状态分割成 一些不相关的子集，使得任何不同的两个子集 状态都是可区别的，而同一个子集中的任何状 态都是等价的。

![image-20241118171144257](D:\ziliao\编译原理\笔记\11\24.png)

先分成两块，将里面的数字全部替换成块号，不能区分的放一起，组成一个新的块，然后重复上述步骤，将数字替换成块号

![image-20241118171555233](D:\ziliao\编译原理\笔记\11\25.png)

![image-20241118171610121](D:\ziliao\编译原理\笔记\11\26.png)

![image-20241118171624579](D:\ziliao\编译原理\笔记\11\27.png)

证明两个DFA相等：转换成正则表达式，看是否相等

**注意：最小化后的结果状态不一定减少，比如作业题**