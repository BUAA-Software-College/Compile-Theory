# 中间代码优化

## 1、概述

代码优化（code  optimization)：指编译程序为了生成高质量的目标程序而做的各种加工和处理。

目的：提高目标代码运行效率

- 时间效率（减少运行时间）
- 空间效率（减少内存容量）（嵌入式设备容量小）

原则：进行优化必须严格遵循“不能改变原有程序语义”原则。

- 等价原则
- 有效原则（优化必须有效）
- 合算原则：尽可能低的代价

多线程编程中，多个线程同时存取共享变量x（初始值 0）时，需要使用“忙等待”控制多个线程顺序存取之（临界区）。这里的空语句就不可被优化掉！

**优化方法的分类（按范围分）：**

- 局部优化：指在基本块内进行的优化。例如，局部公共子表达式删除
- 循环优化：对循环语句所生成的中间代码序列上所进行的优化。
- 全局优化：跨越基本块，在函数/过程内进行的优化，需要进行全局控制流和数据流分析。例如全局数据流分析。
- 跨函数优化：整个程序。例如跨函数别名分析，逃逸分析等

**基本块定义**：

基本块中的代码是连续的语句序列。

程序的执行（控制流）只能从基本块的第一条语句进入。

程序的执行只能从基本块的最后一条语句离开。

分块可以获得分支信息等

基本块内的代码调用次数相同，要么都调用要么都不调用

**算法14.1   划分基本块**

输入：四元式序列 （注意：一般不在原高级语言上划分）

输出：基本块列表。每个四元式仅出现在一个基本块中

方法：

1. 首先确定入口语句（每个基本块的第一条语句）的集合。
   - 规则1：整个语句序列的第一条语句属于入口语句；
   - 规则2：任何能由条件/无条件跳转语句转移到的第一条语句属于入口语句；
   - 规则3：紧跟在跳转语句之后的第一条语句属于入口语句。
2. 每个入口语句直到下一个入口语句，或者程序结束，它们之间的所有语句都属于同一个基本块。

![image-20241028161754610](D:\ziliao\编译原理\笔记\14\1.png)

第2行称为第3行前驱，第3行是第2行后继

**流图：**

- 流图是一种有向图

- 流图的结点是基本块
- 如果在某个执行序列中，B2的执行紧跟在B1之后，则从B1到B2有一条有向边
- 我们称B1为B2的前驱，B2为B1的后继
  - 从B1的最后一条语句有条件或者无条件转移到B2的第一条语句；或者：
  - 按照程序的执行次序，B2紧跟在B1之后，并且B1没有无条件转移到其他基本块。

**循环的查找**：

程序流图中，从首节点出发，任何到达B的路径都要经过A，则记为A dom B，A是B的必经节点。

dom(A)为A的必经节点集合；“经过不包括起始节点，但包括终点”；所以点A一定属于dom(A)

**注意：一定是“不得不经过”，如果有选择，那么能选择的点都不是必经节点**

如果有边B->A且A dom B，则该边为循环的**回边**，**循环体包括能够到达B且不经过A的所有节点**（循环体**一定包含A和B**，因为显然B可以到达B，而A可以不**经过A**而到达B（起始不算经过））

![77c799f67b55092711a9d1f6158bf77](D:\ziliao\编译原理\笔记\14\2.png)

乘法运算速度比加法，减法速度慢一个数量级（强度削弱，能做加减不乘除）

## 2、基本块内优化

（1）利用代数性质（代数变换）

- 编译时完成常量表达式的计算，整数类型与实型的转换。
- 例： a := 5 + 6 + x   →    a := 11 + x （常数合并）
  又如： 设x为实型，x := 3 + 1            可变换成x := 4.0
- 下标变量引用时，其地址计算的一部分工作可在编译时预先做好（运行时只需计算“可变部分”即可）。
- 运算强度削弱：用一种需要较少执行时间的运算代替另一种运算，以减少运行时的运算强度(时、空开销)。

![image-20241028165544769](D:\ziliao\编译原理\笔记\14\3.png)

能不用函数，就不要用；

（2）复写(copy)传播：

如x := y 这样的赋值语句称为复写语句。由于x 和y 值相 同，所以当满足一定条件时，在该赋值语句下面出现的x 可用 y 来代替。

![image-20241028170115582](D:\ziliao\编译原理\笔记\14\4.png)

（3）删除冗余代码：

冗余代码就是毫无实际意义的代码，又称死代码(dead  code)或无用代码(useless   code)。

![image-20241028170413006](D:\ziliao\编译原理\笔记\14\5.png)

**基本块内优化: 消除公共子表达式**

**期末必考，题量不少**

![image-20241028170625629](D:\ziliao\编译原理\笔记\14\6.png)

可通过DAG图消除公共子表达式

![image-20241028170709108](D:\ziliao\编译原理\笔记\14\7.png)

- **图的叶结点由变量名或常量所标记**。（对于那些在基本块内先引用再赋值 的变量，可以采用变量名加下标0的方 式命名其初值）。
- **图的中间结点由中间代码的操作符所标记**，代表着基本块中一条或多条中 间代码。
- **基本块中变量的最终计算结果都对应着图中的一个结点**；具有初值的变量， 其初值和最终值可以分别对应不同的 结点。

![image-20241028171204775](D:\ziliao\编译原理\笔记\14\8.png)

SSA：静态单赋值

公共子表达式：中间参与运算的符号不能再变值，比如不能c = c+1

### 算法14.2 构建DAG图的算法—消除公共子表达式

- 输入：基本块内的中间代码序列
- 输出：完成局部公共子表达式删除后的DAG图
- 方法：

1. 首先建立结点表，该表记录了变量名和常量值，以及它们当前所对 应的DAG图中结点的序号。该表初始状态为空。
2. 从第一条中间代码开始，按照以下规则建立DAG图。
3. 对于形如z = x op y的中间代码，其中z为记录计算结果的变量名，x 为左操作数，y为右操作数，op为操作符：首先在结点表中寻找x， 如果找到，记录下x当前所对应的结点号i；如果未找到，在DAG图 中新建一个叶结点，假设其结点号仍为i，标记为x（如x为变量名， 该标记更改为x0）；在结点表中增加新的一项(x, i)，表明二者之间 的对应关系。右操作数y与x同理，假设其对应结点号为j。**注意：对于赋值，结点号不变，比如t = a+b; z = t，则z和t编号一样**
4. 在DAG图中寻找中间结点，其标记为op，且其左操作数结点号 为i，右操作数结点号为j。如果找到，记录下其结点号k；如果 未找到，在DAG图中新建一个中间结点，假设其结点号仍为k， 并将结点i和j分别与k相连，作为其左子结点和右子结点。
5. 在结点表中寻找z，如果找到，将z所对应的结点号更改为k；如 果未找到，在结点表中新建一项(z, k)，表明二者之间的对应关 系。
6. 对输入的中间代码序列依次重复上述步骤3～5。

### 10.2.2、基本块的DAG表示及应用

一个基本块，可用一个DAG来表示与各四元式相对应的 DAG结点形式:

0. 0型：A := B  (:=，B，-，A)（四元式可以为空）

   ![image-20241030095459662](D:\ziliao\编译原理\笔记\14\9.png)

1. 1型:   A := op B； (op，B，-，A)（比如取反操作）

2.  2型:   A := B op C  (op，B，C，A)

![image-20241030095552244](D:\ziliao\编译原理\笔记\14\910.png)

![image-20241030095624124](D:\ziliao\编译原理\笔记\14\11.png)

![image-20241030095715692](D:\ziliao\编译原理\笔记\14\12.png)

注：（5）是三目运算，需要D，C和B；而（3）相当于先找B[c]的地址再赋值

![image-20241030100528689](D:\ziliao\编译原理\笔记\14\13.png)

![image-20241030100556060](D:\ziliao\编译原理\笔记\14\14.png)

从DAG中还能得到其他的优化信息：

- 在基本块外被定值并在基本块内被引用的所有标识符，就是作为**叶子结点**上标记的那些标识符。

- 在基本块内被定值并且该值在基本块后面可以被引用的所有标识符，就是DAG各结点上的那些附加标识符。

**将数组变量a作为一个单独的变量进行考虑**， 将形如x = a[i]的中间代码都表示为x = a []  i，其中[]为数组取值操作符；形如a[j] = y 的中间代码都表示为a = j “[]=” y，其中 “[]=”为数组成员赋值操作符。

**指针：保守处理**

函数调用：在缺乏跨函数数据流分析的支持下，需要保守地假设函数调用改变了所有它可能改变的数据。

### 算法14.3 从DAG导出中间代码的启发式算法

编程可以调用的存储只有寄存器；其它无法选择存在哪里

由于寄存器速度快，所以临时变量要尽可能放在寄存器中。

![image-20241030103338003](D:\ziliao\编译原理\笔记\14\15.png)

- 输入：DAG图 
- 输出：中间代码序列 
- 方法： 
  1. 初始化一个放置DAG图中间结点的队列。
  2.  如果DAG图中还有中间结点未进入队列，则执行步骤3，否则执行步骤5
  3. 选取一个尚未进入队列，但其**所有父结点均已进入队列**的中间结点n， 将其加入队列；或选取**没有父结点**的中间结点，将其加入队列 
  4. 如果n的最左子结点符合步骤3的条件，将其加入队列；并沿着当前结点的**最左边**，**循环访问其最左子结点，最左子结点的最左子结点**等，将符合步骤3条件的**中间结点**依次加入队列；如果出现不符合步骤3条件的最左子结点，执行步骤2 
  5. 将中间结点队列逆序输出，便得到中间结点的计算顺序，将其整理成中间代码序列

注意：进入队列的都是中间节点；每一次进入队列后优先找最左子节点；

生成DAG图时，对于x op y x必须在左侧，y必须在右侧，所以DAG图唯一，这也使得这个方法生成的新中间代码也是唯一的。

### 2.3、窥孔优化

- 窥孔优化关注在目标指令的一个较短的序列上，通常称其 为“窥孔”（peephole）。
- 通过删除其中的冗余代码，或者用更高效简洁的新代码来 替代其中的部分代码，达到提升目标代码质量的目的。
- 窥孔优化并不局限在同一 个基本块中，可跨越基本块，甚至包含多个基本块。

## 3、全局优化

### 3.1、数据流分析

- 用于获取数据在程序执行路径中如何流动的有关信息。例如：
  - 某个变量在某个特定的执行点（语句前后）是否还“存活”？
  - 某个变量的值，是在什么地方定义的？
  - 某个变量在某一执行点上被定义的值，可能在哪些其他执行点被使用？
- 是全局优化的基础

#### 数据流分析方程

（会出大题）

![image-20241030105309161](D:\ziliao\编译原理\笔记\14\16.png)

进入的数据，减去已经使用不再需要的数据，再并上自己产生的数据，就是最后得到的数据。

（类比财产的继承，花钱，挣钱）

**程序的状态**：

- 程序的执行过程= 程序状态的变换过程
  - 程序状态由程序中的变量和其它数据结构组成。
  - 每一条执行指令都可能改变程序的状态。
- 一种常用的数据流分析方法：到达定义。
- 通过数据流分析，可以了解程序的状态。
  - 如果得知在某条中间代码之后，无论程序在实际执行时通 过哪条路径，某个变量都不会再被访问，那么该变量此前所占有 的全局寄存器或临时寄存器就可以安全地被其他变量重新使用。
  - 如果得知在程序的某个点上，对某个变量进行引用时，无 论程序如何运行，该变量都仅具有某个唯一的常量值，那么就可 以将该常量引入中间代码，在代码生成时生成更高效的指令。

**到达定义（reaching definition）分析**：

- 在程序的某个静态点p，例如某条中间代码之前或者之后， 某个变量可能出现的值都是在哪里被定义的？
- 在p处对该变量的引用，取得的值是否在d处定义？
  - 如果从定义点d出发，存在一条路径达到p，并且在该路径上， 不存在对该变量的其他定义语句，则认为“变量的定义点d到 达静态点p”。
  - 如果路径上**存在对该变量的其他赋值语句**，那么路径上的前一 个定义点就被路径上的后一个定义点“**杀死**”，或者**消除**了。**不看流图的方向，只看定义的语句，互相“杀死”**
- **说明**：
  - 变量的定义：赋值语句、过程参数、指针引用等多种形式。
  - 不能判断时：保守处理

![image-20241030110624213](D:\ziliao\编译原理\笔记\14\17.png)

比如这张图，不看流图的方向，只看定义的语句是谁“杀死”了谁（谁有可能被谁赋值）。因为可能执行顺序不确定（**保守处理，因为实际程序的顺序可能很难确定**）。

![image-20241030111627003](D:\ziliao\编译原理\笔记\14\18.png)

![image-20241030111640675](D:\ziliao\编译原理\笔记\14\19.png)

可以推出下图的公式：

![image-20241030111734321](D:\ziliao\编译原理\笔记\14\20.png)

![image-20241030112001465](D:\ziliao\编译原理\笔记\14\21.png)

因此，后续只用考虑d2，优化掉d1

### 算法14.5  基本块的到达定义数据流分析

- 输入：程序流图，且基本块的kill集合和gen集合已经计算完毕
- 输出：每个基本块入口和出口处的in和out集合，即in[B]和 out[B]
- 方法：

	1. 将包括代表流图出口基本块B_exit的所有基本块的out集合，初始化为空集。
	1. ![image-20241030112203291](D:\ziliao\编译原理\笔记\14\22.png)

​	循环计算的原因：每一次循环针对整个程序所有的块；in[B]会发生变化；

![image-20241030112456150](D:\ziliao\编译原理\笔记\14\23.png)

![image-20241030112512428](D:\ziliao\编译原理\笔记\14\24.png)

### 3.2、活跃变量分析

与流图路径反方向计算

- 了解变量x在某个执行点p是活跃的
  - 变量x的值在p点或沿着从p出发的某条路经中会被使用， 则称x在p点是活跃的。
- 通过活跃变量分析，可以了解到某个变量x在程序的某个 点上是否活跃，或者从该点出发的某条路径上是否会被使 用。如果存在被使用的可能，x在该程序点上便是活跃的； 否则就是非活跃，或者死的。

- 对于寄存器分配，不论是全局寄存器分配还 是临时寄存器分配都有重要意义。
  - 如果拥有寄存器的变量x在p点开始的任何路径上不再活跃，可以释放寄存器。
  - 如果两个变量的活跃范围不重合，则可以共享同一个寄存器。

对于跨基本块的变量，那么用寄存器更快，避开从内存读取

![image-20241104160715281](D:\ziliao\计算机网络\笔记\5\26.png)

例如：x = a+b, y = x+1

则a,b是先使用后定义，放入use；x是先定义后使用，放入def；y是先定义未使用，也属于“定义先于使用”，放入集合def。

**x = x+1，x是先使用后定义，由于需要先知道x的值才能+1.**

**这里是根据out得出in，out是后继基本块；与到达定义分析相区别，到达定义分析是已知前继的in得到out**

活跃变量分析的直观理解：如果在路径后方的某个基本块中， 变量x被使用，则沿着执行路径的逆向直到x被定义的基本块， x都是活跃的。

### 算法14.5基本块的活跃变量数据流分析

- 输入：程序流图，且基本块的use集合和def集合已经计算 完毕
- 输出：每个基本块入口和出口处的in和out集合，即in[B] 和out[B]
- 方法： 
  - 1. 将包括代表流图出口基本块Bexit在内的**所有基本块的in集合， 初始化为空集**。 （到达定义分析，初始化out集合为空）
  - 2. 根据方程out[B] = ∪B的后继基本块P in[P]，in[B] = use[B] ∪ (out[B] – def[B])，为每个基本块B依次计算集合out[B]和 in[B]。如果计算得到某个基本块的in[B]与此前计算得出的 该基本块in[B]不同，则循环执行步骤2，直到所有基本块的 in[B]集合不再产生变化为止。

![image-20241104161836407](D:\ziliao\计算机网络\笔记\5\27.png)

![image-20241104162908527](D:\ziliao\计算机网络\笔记\5\28.png)

- 变量x, y, i：均定义于B1，在B2~B5 入口处均活跃。 注意，x在B3、B4中都被重新定义过， 但x被定义前均被使用过，因此其在 同一基本块中发生在使用之前的定 义仅余B1。变量y和i的情况类似。
- 变量a：在流图中无定义点，在 B1~B5入口处均活跃。
- 变量b：在流图中无定义点，在B1入 口处活跃。
- 变量z：定义于B3，且仅在B3中被使用。

对于z，不跨基本块，可以分配临时寄存器

**冲突图**：

![image-20241104163240109](D:\ziliao\计算机网络\笔记\5\29.png)

假设只有跨越基本块活跃的变量才能分配到全局寄存器，并且**活跃范围重合**的变量之间无法共享全局寄存器。

### 3.3、定义-使用链、网和冲突图

- 冲突图：其结点是待分配全局寄存器的变量，当两个变量中的一个变量在另一个变量定义（赋值）处是活跃的， 它们之间便有一条边连接。

例如，x在定义处有其它变量活跃，则x和这些变量都冲突。

![image-20241104163530548](D:\ziliao\计算机网络\笔记\5\30.png)

**关于变量冲突的判断**

- 两个变量中的一个变量在另一个变量定义（赋值）处是活跃的，它们就是冲突的
  - 算法一：在每一个变量的定义点计算活跃变量。
  - 算法二：计算基本块入口处的活跃变量（in的集合），这些变量在该基本块中的定义点活跃，因而冲突。之后，在基本 块内部，进一步计算每个定义点的活跃变量（基本块范围内 计算），降低了计算的复杂度，因为基本块内部是线性的。

![image-20241104164358951](D:\ziliao\计算机网络\笔记\5\31.png)

**所谓变量的定义-使用链，是指变量的某一定义点，以及所有 可能使用该定义点所定义变量值的使用点所组成的一个链**

比如：先定义了x，然后定义y=x+1，那么x与y组成一条链。

![image-20241104164930748](D:\ziliao\计算机网络\笔记\5\32.png)

![image-20241104165549280](D:\ziliao\计算机网络\笔记\5\33.png)

![image-20241104165606598](D:\ziliao\计算机网络\笔记\5\34.png)

注意：有某个同样的使用点，才能合并成一个网。

## 4、循环优化

除了对循环体进行优化，还有专用于循环的优化

a) 循环不变式的代码外提

不变表达式：不随循环控制变量改变而改变的表达式或子表达式。

![image-20241104170015804](D:\ziliao\计算机网络\笔记\5\35.png)

b) 循环展开

循环展开是一种优化技术。它将构成循环体的代码(不 包括控制循环的测试和转移部分)，重新产生许多次(这可在 编译时确定)，而不仅仅是一次。以空间换时间!

![image-20241104170155246](D:\ziliao\计算机网络\笔记\5\36.png)

说明：

- 一般不适用于do{}while();语句
- 优化在生成代码时进行，并不是修改源程序。
- 必须知道循环的初值、终值及步长。
- 但非所有展开都是合适的。若循环体中不是一条而是40条，则展开将有40*30=1200条，但省的仍是60条，就不算优化了。

**判断准则：1. 主存资源丰富处理机时间昂贵  2. 循环体语句越少越好**

c)  归纳变量的优化和条件判断的替换

归纳变量(induction variable):  在每一次执行循环迭代的 过程中，若某变量的值固定增加（或减少）一个常量值， 则称该变量为归纳变量(induction  variable)。即若当前执 行循环的第j 次迭代，归纳变量的值应为c * j + c’, 这里c  和c’都是循环不变式。

![image-20241104171655261](D:\ziliao\计算机网络\笔记\5\37.png)

d)  其它循环优化方法

- 把多重嵌套的循环变成单层循环。
- 把n 个相同形式的循环合成一个循环等。

**in_line 展开**

把过程（或函数）调用改为in_line展开可节省许多处理过程 （函数）调用所花费的开销。

就是C语言的内联函数，仅限于简单函数

**SSA**：静态单一赋值形式的IR 主要特征是**每个变量只赋值一次**。 

SSA的优点：1）可以简化很多优化的过程； 2）可以获得更好的优化结果。

例如，x=1; x = x-1,变成x1 = 1; x2 = x1 - 1

SSA的关键问题——如何加入phi节点？

![image-20241104172301079](D:\ziliao\计算机网络\笔记\5\38.png)

![image-20241104172333065](D:\ziliao\计算机网络\笔记\5\39.png)

![image-20241104172348995](D:\ziliao\计算机网络\笔记\5\40.png)