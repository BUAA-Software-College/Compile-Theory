# 第十章 语义分析和代码生成

假定: 

• 源语言： 通用的过程语言 

• 生成代码：栈式抽象机的（伪）汇编程序 

• 翻译方法：自顶向下的属性翻译 

• 语法成分翻译子程序参数设置：

​	– 继承属性为值形参

​	– 综合属性为变量形参

 • 语法成分翻译动作子程序参数设置：

​	– 继承属性为值形参

​	– 综合属性不设形参，而作为动作子程序的返回值 （由RETURN语句返回）

## 10.1、语义分析的概念

1. 上下文有关分析：即标识符的作用域

2. 类型的一致性检查

3. 语义处理： 

   声明语句：其语义是声明变量的类型等，并不要求做其他的操作。 语义分析程序的工作是填符号表，登录名字的特征信息，分配存储。

   执行语句：语义是要做某种操作。 语义处理的任务：按某种操作的目标结构生成中间代码或目标代码。

用**上下文无关文法只能描述语言的语法结构，而不能描述其语义**！

例如：![image-20241021160753189](D:\ziliao\编译原理\笔记\10\1.png)

所有运算在栈顶运行，没有特制的ALU

## 10.2 栈式抽象机及其汇编指令

栈式抽象机：由三个存储器、一个指令寄存器和多个地址寄存器组成。

存储器：数据（存放AR的运行栈），操作（操作数栈），指令存储器

![image-20241021161518276](D:\ziliao\编译原理\笔记\10\2.png)

![image-20241021161627356](D:\ziliao\编译原理\笔记\10\3.png)

![image-20241021161646835](D:\ziliao\编译原理\笔记\10\4.png)

几目运算符就弹几个元素。

ALC是在栈里开空间，而malloc是堆开空间。

## 10.3 声明的处理

语义的表示：

给出语言结构的属性翻译文法来说明其语义及语义动作，并把这些语义动作插入属性翻译文法产生式中的适当位置。

编译程序的任务：

编译程序处理声明语句要完成的主要任务为：

1) 分离出每一个被声明的实体，并把它们的名字填入符号表中 
2) 把被声明实体的有关特性信息尽可能多地填入符号表中

对于已声明的实体，在处理对该实体的引用时要做的事情：

1) 检查对所声明的实体引用（种类、类型等）是否正确
2) 根据实体的特征信息，例如类型、所分配的目标代码地址（可能 为数据区单元地址，或目标程序入口地址）生成相应的目标代码

也就是说，处理声明语句主要是做填表工作（填表前先得查表，检查是否重名）。处理对已声明的实体的引用时主要是做查表工作。

声明的两种方式：

 (1) 类型说明符放在变量的前面。如C语言：int  a; 在填表时 已知类型和a的值（名字），直接填入符号表。 

(2) 类型说明放符在变量的后面。如：Pascal，PL/1，Ada等， 需要返填。（拉链回填技术）

![image-20241021163614307](D:\ziliao\编译原理\笔记\10\5.png)

### 10.3.1 常量类型声明处理

常量标识符通常被看作是全局名。

![image-20241021164429992](D:\ziliao\编译原理\笔记\10\6.png)

![image-20241021165016282](D:\ziliao\编译原理\笔记\10\7.png)

### 10.3.2 简单变量声明处理

填局部符号表

![image-20241021165251411](D:\ziliao\编译原理\笔记\10\8.png)

对于变长字符串（或其它大小可变的数据实体），往往需要采用动态申请存储空间的办法把可变长实体存储在堆中。

一般用malloc，new生成的内容在堆里，地址信息在栈里

 a）n维数组的地址计算公式：设数组的维数为n，各维的下界和上界为L(i)和U(i) 

![image-20241021170711406](D:\ziliao\编译原理\笔记\10\9.png)

LOC是首元素的地址；ADR是当前元素的地址

![](D:\ziliao\编译原理\笔记\10\10.png)

![image-20241021171041194](D:\ziliao\编译原理\笔记\10\11.png)

乘法的原因：要知道有几个，肯定要知道“面积”

![image-20241021172007878](D:\ziliao\编译原理\笔记\10\12.png)

b) 数组信息向量表（模板）

功能：1、用于计算下标变量地址  2、检查下标是否越界

![image-20241021172314960](D:\ziliao\编译原理\笔记\10\13.png)

**大小：3n+2**

注：

1、数组模板所需的空间大小取决于数组的维数，即3n+2 ；

无论是常界或变界数组，在编译时就能确定数组模板的大小 

2、常界数组，在编译时就可造信息向量表；而变界数组信息向量 表要在目标程序运行时才能构造。编译程序要生成相应的指令

![image-20241021172631330](D:\ziliao\编译原理\笔记\10\14.png)

![image-20241023094806380](D:\ziliao\编译原理\笔记\10\15.png)

![image-20241023094829636](D:\ziliao\编译原理\笔记\10\16.png)

数组信息向量表存放在AR的“数组模板”位置中，编译时构造，运行时加载；

动作序列的先后顺序就是处理的先后顺序

1) 动作程序@init 的功能为在分配给数组模板区中保留两个存储单元，用来放**RC 和n**，并将维数计数器j 清0。（总共存储3n+2）

![image-20241023095741233](D:\ziliao\编译原理\笔记\10\17.png)

2) @dimen#↑j :      j := j + 1, 即**统计维数**

3) @bannds将省略下界表达式情况的u => U(i), 但应把相应的L(i) 置成隐含值1, 然后计算P(i)

   注：实际P(i)计算公式可利用P(i)＝[ U(i+ 1) -L(i +1) +1]×P(i+1)

4) @lowerbnd把l => L(i ) @upperbnd把u => U(i ), 并计算P(i)；数组信息向量也由它们负责填写。

5) 最后的动作程序@symbinsert是把数组名n，数组维数j 和数组元素类型t 及数组标志k填入符号表中；为数组分配存储空间。这里存放在活动记录AR的“数组F”中，在堆上分配空间。

**对于变界数组**：

4) @lowerbnd↓l 生成将l => L(i) 的代码 

   @upperbnd↓u 生成把u => U(i)的代码, 生成计算P(i) 的代码； 生成将P(i ) 的值送模板区的代码；

5) @symbinsert ↓j, n, t, k 

   a) 把j, n, t, k 填入符号表中 

   b) 生成调用运行子程序代码（计算RC, 并将计算结果和数组 名一起存入模板区；计算数组所需数据区大小，为数组分配存储 空间，并将头地址填入符号表。）

   事实上，C语言L(i)一定是0，所以只用存2n+2即可。

## 4、表达式的处理

分析表达式的主要目的是生成计算该表达式值的代码。

把表达式中的操作数装载（LOAD）到操作数栈 （或运行栈）栈顶单元或某个寄存器中，然后执行表达式所指 定的操作，而操作的结果保留在栈顶或寄存器中。

**这个栈是操作栈；而AR所在的栈是数据栈**

**注：操作数栈即操作栈，它可以和前述的运行栈 （动态存储分配）合而为一，也可单独设栈**

事实上内存上可以设置任意多个栈。但是分开栈可能会产生内存碎片

![image-20241023102444873](D:\ziliao\编译原理\笔记\10\18.png)

![image-20241023103310696](D:\ziliao\编译原理\笔记\10\19.png)

最终结果栈顶是x+y*3

（**书面考试基本不会出这里的题**）

![image-20241023104636367](D:\ziliao\编译原理\笔记\10\20.png)

![image-20241023104807081](D:\ziliao\编译原理\笔记\10\21.png)

**过程template发送一条目标机指令‘TMP’, 该指令把数组的模板地址加载到操作数栈顶，并将下标（维数）计数器k清0。**

offset过程要确保每一个下标都是整型，而且发送一条‘OFS’指令，该指令在运行时要完成以下功能：

1. 检查第k个下标值是否在栈顶并是否在上下界范围内
2. 使用下列递归函数，计算地址计算公式中可变部分： VP(0) = 0; VP(k) = VP(k-1) + V(k) *P(k)     1≤k≤n；该VP函数是由计算公式 V(k) * P(k) 求和 导出的

下面以数组元素B(2,1)为例，说明 

（a）执行TMP指令并形成第一个下标值的情况 

（b）执行第一个OFS指令并形成第二个下标值的情况 

（c）执行第二个OFS指令及ARR指令后的情况 

（d）执行DER指令，最后在栈顶形成下标变量B(2,1)的值

![image-20241023105722790](D:\ziliao\编译原理\笔记\10\22.png)

首先找数组的模板地址，得到RC，dim等；先看是否越界，然后找到LocB，并计算VP（就是V(i) * P(i)的和），找到对应的数组元素

## 5、 赋值语句的处理

![image-20241023110613933](D:\ziliao\编译原理\笔记\10\23.png)

## 6、控制语句的处理

![image-20241023110641785](D:\ziliao\编译原理\笔记\10\24.png)

![image-20241023110724790](D:\ziliao\编译原理\笔记\10\25.png)

![image-20241023111812097](D:\ziliao\编译原理\笔记\10\26.png)

## 7、过程调用和返回

### 参数传递的基本形式

1. 传值（call by value) — 值调用

2. 传地址（call by reference) —引用调用

3. 传名（call by name )

   又称“名字调用”。即把实参名字传给形参。这样在过程体中引用形参时，都相当于对当时实参变量的引用。 

   当实参变量为下标变量时，传名和传地址调用的效果可能会完全不同。 传名参数传递方式，实现比较复杂，其目标程序运行效率较低, 现已很少采用。

![image-20241023112453628](D:\ziliao\编译原理\笔记\10\27.png)

目前传参数都是通过寄存器传。