# 目标代码生成及优化

面向目标体系结构的代码生成和优化技术

C#生成的.exe是文本，不是二进制

.lib是动态链接库（运行链接），.dll是静态链接库（编译链接）；

## 1、现代微处理器体系结构简介

![image-20241106101806794](D:\ziliao\编译原理\笔记\15\1.png)

1、栈式指令集架构

类似于P-code和Java虚拟机

push和pop都是访存指令，add是ALU指令；

2、累加器结构

load，add，store都是访存指令；add的两个操作数，一个从cpu来，1个从内存中来

3、寄存器-内存式架构（x86）

![image-20241106102408659](D:\ziliao\编译原理\笔记\15\2.png)

寄存器-内存式，add既是alu指令又是访存指令，x86 CISC架构

寄存器-寄存器式，mips/arm，RISC架构

![image-20241106102800188](D:\ziliao\编译原理\笔记\15\3.png)

![image-20241106102817978](D:\ziliao\编译原理\笔记\15\4.png)

### 1.2、存储层次架构

缓存的管理单位是：缓存行（数十或上百字节）

每次从内存载入的是一组地址连续的数据，而不仅仅是被访问数据。

## 2、地址空间

代码区 ➢存放目标代码

程序运行栈 

​	➢活动记录 

​	➢函数调用的上下文现场

静态数据区

动态内存区

- 也被称为内存堆Heap 
- 程序员管理：C、C++
- 自动管理（内存垃圾收集器）：Java、Ada

![image-20241111160647353](D:\ziliao\编译原理\笔记\15\5.png)

### 2.2、程序运行栈的设计

- 子程序/函数运行时所需的基本空间：活动记录
- 进入子程序/函数时分配，地址空间向下生长（从高 地址到低地址）
- 从子程序/函数返回时，当前运行栈将被废弃
- 递归调用的同一个子程序/函数，每次调用都将获得独立的运行栈空间，从而保证了递归程序和多线程程序的正确运行。

形参不超过4个不用压栈；超过需要压栈

**C语言没有display区，可以是分程序结构，也可以是非分程序结构**

活动记录采用链表结构，递归向前找调用的函数

## 3、寄存器的分配和指派

### 3.1、全局寄存器分配

“全局”相对于“基本块”而言，不是“程序全局”。不跨基本块只需要临时寄存器

全局寄存器分配的对象主要是函数的局部变量，包括函数 入口参数。

**寄存器专属于线程**

**分配原则**：

- 优先分配给跨基本块仍然活跃的变量，尤其是循环体内最活跃的变量。
- 局部变量参与全局寄存器分配。
- 为了**线程安全**，全局变量/静态变量一般不参与全局寄存器分配。
- 如果发生线程切换，当前的寄存器状态将作为 线程现场被保存，切入线程将恢复其此前保存的寄存器 状态，这就导致了其他线程无法得到该寄存器在此前线 程中的值

（进程资源分配指的是内存）

**常用全局寄存器分配方法**

- 引用计数：通过统计变量在函数内被引用的次数，并根据被引用的 特点赋予不同的权重，最终为每个变量计算出一个唯一 的权值，根据权值的大小排序，将全局寄存器依次分配 给权值最大的变量
- 着色图算法：构建变量之间的冲突图，在图上应用着色算法，将 不同的全局寄存器分配给有冲突的变量。

### 1、引用计数

- 原则：如果一个局部变量 被访问的次数较多，那么 它获得全局寄存器的机会 也较大
- 注意：出现在循环，尤其 是内层嵌套循环中的变量 的被访问次数应该得到一 定的加权
- 分配算法：如果有N个全局寄存器可供分配，则 前N个变量拥有全局寄存器，其余变量在程序运 行栈（活动记录）分配存贮单元
- 问题：不再使用的变量不能及时释放寄存器
  - 解决：活跃变量分析、冲突图；着色算法

### 2、图着色算法

1. 通过数据流分析，**构建变量的冲突图**
2. 如果可供分配k个全局寄存器，那么我们就**尝试用 k种颜色给该冲突图着色**

![image-20241111163551878](D:\ziliao\编译原理\笔记\15\6.png)

![image-20241111163608529](D:\ziliao\编译原理\笔记\15\7.png)

![image-20241111164544262](D:\ziliao\编译原理\笔记\15\8.png)

### 算法15.2 一种启发式图着色算法

**步骤1**、找到第一个连接边数目小于K的结点（直接找连接边数目最少的节点即可），将它从图G中移走，形成图G’

**步骤2**、重复步骤1，直到无法再从G’中移走结点

**步骤3**、当连接边数目均相同时，在图中选取适当的结点，将它记录为“不分 配全局寄存器”的结点，并从图中移走

**步骤4**、重复步骤1~步骤3，直到图中仅剩余1个结点

**步骤5**、给剩余的最后一个结点选取一种颜色，然后按照结点被移走的顺序，反向将结点和边添加进去，并依次给新加入的结点选取颜色。（**保证有链接边的结点着不同的颜色**）

![image-20241111165357442](D:\ziliao\编译原理\笔记\15\9.png)

![image-20241111165444525](D:\ziliao\编译原理\笔记\15\10.png)

![image-20241111165457447](D:\ziliao\编译原理\笔记\15\11.png)

![image-20241111165512301](D:\ziliao\编译原理\笔记\15\12.png)

![image-20241111165603597](D:\ziliao\编译原理\笔记\15\13.png)

### 3.2、临时寄存器分配

不超越基本块，不跨越函数调用

管理方法：寄存器池

![image-20241111170341058](D:\ziliao\编译原理\笔记\15\14.png)

- 进入基本块时，清空临时寄存器池
- 为当前中间代码生成目标代码时，无论临时变量还是局部变 量（亦或全局变量和静态变量），如需使用临时寄存器，都 可以向临时寄存器池申请
- 临时寄存器池接到申请后
  - 如寄存器池中有空闲寄存器，则可将该寄存器标识为被该 申请变量占用，并返回该空闲寄存器
  - 如寄存器池中没有空闲寄存器，则选取一个在即将生成代 码中不会被使用的寄存器写回相应的内存空间，标识该寄 存器被新的变量占用，返回该寄存器
- 在基本块结尾，或者函数调用发生前，将寄存器池中所有被 占用的临时寄存器写回相应的内存空间，清空临时寄存器池

## 4、指令选择

不同的体系结构采用了不同类型的指令集，由 于体系结构和指令集的差异，使得在生成代码时需 要采用不同的指令选择策略。

汇编代码，结果放在前面，操作数在后面；op a b c

